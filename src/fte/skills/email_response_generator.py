"""Email Response Generator Skill - Generate AI-powered email responses."""

import sys
from pathlib import Path
from typing import Dict, Any

# Add the src directory to the Python path
src_path = Path(__file__).parent.parent.parent
sys.path.insert(0, str(src_path))

from fte.vault_manager import VaultManager


def generate_email_response(email_file_path: str, custom_instructions: str = "") -> Dict[str, Any]:
    """Generate an AI-powered response to an email.

    Args:
        email_file_path: Path to the email file in the vault
        custom_instructions: Additional instructions for the AI on how to respond

    Returns:
        Dictionary with result of the operation
    """
    try:
        # Initialize vault manager
        manager = VaultManager()

        # Read the email file
        file_path = Path(email_file_path)
        if not file_path.is_absolute():
            file_path = manager.vault_path / file_path

        if not file_path.exists():
            return {
                "success": False,
                "error": f"Email file not found: {email_file_path}"
            }

        content = file_path.read_text(encoding='utf-8')

        # Extract email content for response generation
        extracted_content = extract_email_content(content)

        # Generate response using AI (simulating Claude's response)
        response = create_response(extracted_content, custom_instructions)

        # Append the response to the email file
        updated_content = append_response_to_email(content, response)
        file_path.write_text(updated_content, encoding='utf-8')

        return {
            "success": True,
            "message": f"AI response generated and added to {file_path.name}",
            "response": response,
            "file_path": str(file_path)
        }

    except Exception as e:
        return {
            "success": False,
            "error": f"Error generating response: {str(e)}"
        }


def extract_email_content(email_content: str) -> Dict[str, str]:
    """Extract relevant parts of the email for response generation."""
    subject = "No Subject"
    sender = "Unknown Sender"
    body = email_content

    # Extract frontmatter if present
    if email_content.startswith('---'):
        end_frontmatter = email_content.find('---', 3)
        if end_frontmatter != -1:
            frontmatter = email_content[3:end_frontmatter]

            # Extract metadata
            for line in frontmatter.split('\n'):
                if ':' in line:
                    key, value = line.split(':', 1)
                    key = key.strip()
                    value = value.strip().strip('"\'')

                    if key == 'subject':
                        subject = value
                    elif key == 'from':
                        sender = value

            # Extract body content after frontmatter
            body = email_content[end_frontmatter + 3:].strip()

    return {
        "subject": subject,
        "sender": sender,
        "body": body
    }


def create_response(email_parts: Dict[str, str], custom_instructions: str = "") -> str:
    """Create an appropriate response based on email content."""
    # This is a simulation of what would be an AI call to Claude
    # In a real implementation, this would call the Claude API

    subject = email_parts["subject"]
    sender = email_parts["sender"]
    body = email_parts["body"]

    # Create a prompt for the AI to generate a response
    prompt_context = f"""
    Email from: {sender}
    Subject: {subject}
    Content: {body}

    Please generate an appropriate professional response to this email.
    {custom_instructions}
    """

    # Simulated AI response - in real implementation this would be generated by Claude
    simulated_responses = {
        "testing": f"Thank you for your email regarding '{subject}'. I have received your message and will review it shortly. Best regards.",
        "information": f"I acknowledge receipt of your request for information. I will look into this matter and get back to you soon. Thank you for reaching out.",
        "general": f"Thank you for your email. I have noted your message and will take the necessary actions. I appreciate you contacting me."
    }

    # Determine response type based on content
    lower_body = body.lower()
    if "test" in lower_body or "testing" in lower_body:
        response = simulated_responses["testing"]
    elif "information" in lower_body or "provide" in lower_body or "date" in lower_body:
        response = simulated_responses["information"]
    else:
        response = simulated_responses["general"]

    # Add timestamp
    from datetime import datetime
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    response_with_meta = f"\n\n---\n**AI Generated Response** - {timestamp}\n{response}\n---\n"

    return response_with_meta


def append_response_to_email(original_content: str, response: str) -> str:
    """Append the AI-generated response to the email content."""
    # If the email already has a response section, we should append to it
    # Otherwise, just add the response at the end
    if "---\n**AI Generated Response**" in original_content:
        # Response already exists, so we won't add another one
        return original_content

    return original_content + response


def process_inbox_for_responses(vault_path: str | Path | None = None) -> Dict[str, Any]:
    """Process all emails in the Inbox and generate AI responses for them."""
    manager = VaultManager(vault_path)

    # Get all email files in Inbox
    inbox_files = manager.list_files("Inbox")

    results = {
        "processed": 0,
        "successful": 0,
        "failed": 0,
        "errors": [],
        "details": []
    }

    for email_file in inbox_files:
        result = generate_email_response(str(email_file))

        results["processed"] += 1

        if result["success"]:
            results["successful"] += 1
            results["details"].append({
                "file": email_file.name,
                "status": "success",
                "message": result["message"]
            })
        else:
            results["failed"] += 1
            results["errors"].append({
                "file": email_file.name,
                "error": result["error"]
            })

    return results